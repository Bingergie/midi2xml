//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.5 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package musicxml;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;


/**
 * The attributes element contains musical information that typically changes on measure boundaries. This includes key and time signatures, clefs, transpositions, and staving. When attributes are changed mid-measure, it affects the music in score order, not in MusicXML document order.
 * 
 * <p>Java class for attributes complex type</p>.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.</p>
 * 
 * <pre>{@code
 * <complexType name="attributes">
 *   <complexContent>
 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       <sequence>
 *         <group ref="{}editorial"/>
 *         <element name="divisions" type="{}positive-divisions" minOccurs="0"/>
 *         <element name="key" type="{}key" maxOccurs="unbounded" minOccurs="0"/>
 *         <element name="time" type="{}time" maxOccurs="unbounded" minOccurs="0"/>
 *         <element name="staves" type="{http://www.w3.org/2001/XMLSchema}nonNegativeInteger" minOccurs="0"/>
 *         <element name="part-symbol" type="{}part-symbol" minOccurs="0"/>
 *         <element name="instruments" type="{http://www.w3.org/2001/XMLSchema}nonNegativeInteger" minOccurs="0"/>
 *         <element name="clef" type="{}clef" maxOccurs="unbounded" minOccurs="0"/>
 *         <element name="staff-details" type="{}staff-details" maxOccurs="unbounded" minOccurs="0"/>
 *         <choice>
 *           <element name="transpose" type="{}transpose" maxOccurs="unbounded" minOccurs="0"/>
 *           <element name="for-part" type="{}for-part" maxOccurs="unbounded" minOccurs="0"/>
 *         </choice>
 *         <element name="directive" maxOccurs="unbounded" minOccurs="0">
 *           <complexType>
 *             <simpleContent>
 *               <extension base="<http://www.w3.org/2001/XMLSchema>string">
 *                 <attGroup ref="{}print-style"/>
 *                 <attribute ref="{http://www.w3.org/XML/1998/namespace}lang"/>
 *               </extension>
 *             </simpleContent>
 *           </complexType>
 *         </element>
 *         <element name="measure-style" type="{}measure-style" maxOccurs="unbounded" minOccurs="0"/>
 *       </sequence>
 *     </restriction>
 *   </complexContent>
 * </complexType>
 * }</pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "attributes", propOrder = {
    "footnote",
    "level",
    "divisions",
    "key",
    "time",
    "staves",
    "partSymbol",
    "instruments",
    "clef",
    "staffDetails",
    "transpose",
    "forPart",
    "directive",
    "measureStyle"
})
public class Attributes {

    protected FormattedText footnote;
    protected Level level;
    /**
     * Musical notation duration is commonly represented as fractions. The divisions element indicates how many divisions per quarter note are used to indicate a note's duration. For example, if duration = 1 and divisions = 2, this is an eighth note duration. Duration and divisions are used directly for generating sound output, so they must be chosen to take tuplets into account. Using a divisions element lets us use just one number to represent a duration for each note in the score, while retaining the full power of a fractional representation. If maximum compatibility with Standard MIDI 1.0 files is important, do not have the divisions value exceed 16383.
     * 
     */
    protected BigDecimal divisions;
    /**
     * The key element represents a key signature. Both traditional and non-traditional key signatures are supported. The optional number attribute refers to staff numbers. If absent, the key signature applies to all staves in the part.
     * 
     */
    protected List<Key> key;
    /**
     * Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator.
     * 
     */
    protected List<Time> time;
    /**
     * The staves element is used if there is more than one staff represented in the given part (e.g., 2 staves for typical piano parts). If absent, a value of 1 is assumed. Staves are ordered from top to bottom in a part in numerical order, with staff 1 above staff 2.
     * 
     */
    @XmlSchemaType(name = "nonNegativeInteger")
    protected BigInteger staves;
    /**
     * The part-symbol element indicates how a symbol for a multi-staff part is indicated in the score.
     * 
     */
    @XmlElement(name = "part-symbol")
    protected PartSymbol partSymbol;
    /**
     * The instruments element is only used if more than one instrument is represented in the part (e.g., oboe I and II where they play together most of the time). If absent, a value of 1 is assumed.
     * 
     */
    @XmlSchemaType(name = "nonNegativeInteger")
    protected BigInteger instruments;
    /**
     * Clefs are represented by a combination of sign, line, and clef-octave-change elements.
     * 
     */
    protected List<Clef> clef;
    /**
     * The staff-details element is used to indicate different types of staves.
     * 
     */
    @XmlElement(name = "staff-details")
    protected List<StaffDetails> staffDetails;
    /**
     * If the part is being encoded for a transposing instrument in written vs. concert pitch, the transposition must be encoded in the transpose element using the transpose type.
     * 
     */
    protected List<Transpose> transpose;
    /**
     * The for-part element is used in a concert score to indicate the transposition for a transposed part created from that score. It is only used in score files that contain a concert-score element in the defaults. This allows concert scores with transposed parts to be represented in a single uncompressed MusicXML file.
     * 
     */
    @XmlElement(name = "for-part")
    protected List<ForPart> forPart;
    /**
     * Directives are like directions, but can be grouped together with attributes for convenience. This is typically used for tempo markings at the beginning of a piece of music. This element was deprecated in Version 2.0 in favor of the direction element's directive attribute. Language names come from ISO 639, with optional country subcodes from ISO 3166.
     * 
     */
    protected List<Attributes.Directive> directive;
    /**
     * A measure-style indicates a special way to print partial to multiple measures within a part. This includes multiple rests over several measures, repeats of beats, single, or multiple measures, and use of slash notation.
     * 
     */
    @XmlElement(name = "measure-style")
    protected List<MeasureStyle> measureStyle;

    /**
     * Gets the value of the footnote property.
     * 
     * @return
     *     possible object is
     *     {@link FormattedText }
     *     
     */
    public FormattedText getFootnote() {
        return footnote;
    }

    /**
     * Sets the value of the footnote property.
     * 
     * @param value
     *     allowed object is
     *     {@link FormattedText }
     *     
     */
    public void setFootnote(FormattedText value) {
        this.footnote = value;
    }

    /**
     * Gets the value of the level property.
     * 
     * @return
     *     possible object is
     *     {@link Level }
     *     
     */
    public Level getLevel() {
        return level;
    }

    /**
     * Sets the value of the level property.
     * 
     * @param value
     *     allowed object is
     *     {@link Level }
     *     
     */
    public void setLevel(Level value) {
        this.level = value;
    }

    /**
     * Musical notation duration is commonly represented as fractions. The divisions element indicates how many divisions per quarter note are used to indicate a note's duration. For example, if duration = 1 and divisions = 2, this is an eighth note duration. Duration and divisions are used directly for generating sound output, so they must be chosen to take tuplets into account. Using a divisions element lets us use just one number to represent a duration for each note in the score, while retaining the full power of a fractional representation. If maximum compatibility with Standard MIDI 1.0 files is important, do not have the divisions value exceed 16383.
     * 
     * @return
     *     possible object is
     *     {@link BigDecimal }
     *     
     */
    public BigDecimal getDivisions() {
        return divisions;
    }

    /**
     * Sets the value of the divisions property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigDecimal }
     *     
     * @see #getDivisions()
     */
    public void setDivisions(BigDecimal value) {
        this.divisions = value;
    }

    /**
     * The key element represents a key signature. Both traditional and non-traditional key signatures are supported. The optional number attribute refers to staff numbers. If absent, the key signature applies to all staves in the part.
     * 
     * Gets the value of the key property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the key property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getKey().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Key }
     * </p>
     * 
     * 
     * @return
     *     The value of the key property.
     */
    public List<Key> getKey() {
        if (key == null) {
            key = new ArrayList<>();
        }
        return this.key;
    }

    /**
     * Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator.
     * 
     * Gets the value of the time property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the time property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getTime().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Time }
     * </p>
     * 
     * 
     * @return
     *     The value of the time property.
     */
    public List<Time> getTime() {
        if (time == null) {
            time = new ArrayList<>();
        }
        return this.time;
    }

    /**
     * The staves element is used if there is more than one staff represented in the given part (e.g., 2 staves for typical piano parts). If absent, a value of 1 is assumed. Staves are ordered from top to bottom in a part in numerical order, with staff 1 above staff 2.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getStaves() {
        return staves;
    }

    /**
     * Sets the value of the staves property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     * @see #getStaves()
     */
    public void setStaves(BigInteger value) {
        this.staves = value;
    }

    /**
     * The part-symbol element indicates how a symbol for a multi-staff part is indicated in the score.
     * 
     * @return
     *     possible object is
     *     {@link PartSymbol }
     *     
     */
    public PartSymbol getPartSymbol() {
        return partSymbol;
    }

    /**
     * Sets the value of the partSymbol property.
     * 
     * @param value
     *     allowed object is
     *     {@link PartSymbol }
     *     
     * @see #getPartSymbol()
     */
    public void setPartSymbol(PartSymbol value) {
        this.partSymbol = value;
    }

    /**
     * The instruments element is only used if more than one instrument is represented in the part (e.g., oboe I and II where they play together most of the time). If absent, a value of 1 is assumed.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getInstruments() {
        return instruments;
    }

    /**
     * Sets the value of the instruments property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     * @see #getInstruments()
     */
    public void setInstruments(BigInteger value) {
        this.instruments = value;
    }

    /**
     * Clefs are represented by a combination of sign, line, and clef-octave-change elements.
     * 
     * Gets the value of the clef property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the clef property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getClef().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Clef }
     * </p>
     * 
     * 
     * @return
     *     The value of the clef property.
     */
    public List<Clef> getClef() {
        if (clef == null) {
            clef = new ArrayList<>();
        }
        return this.clef;
    }

    /**
     * The staff-details element is used to indicate different types of staves.
     * 
     * Gets the value of the staffDetails property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the staffDetails property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getStaffDetails().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link StaffDetails }
     * </p>
     * 
     * 
     * @return
     *     The value of the staffDetails property.
     */
    public List<StaffDetails> getStaffDetails() {
        if (staffDetails == null) {
            staffDetails = new ArrayList<>();
        }
        return this.staffDetails;
    }

    /**
     * If the part is being encoded for a transposing instrument in written vs. concert pitch, the transposition must be encoded in the transpose element using the transpose type.
     * 
     * Gets the value of the transpose property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the transpose property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getTranspose().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Transpose }
     * </p>
     * 
     * 
     * @return
     *     The value of the transpose property.
     */
    public List<Transpose> getTranspose() {
        if (transpose == null) {
            transpose = new ArrayList<>();
        }
        return this.transpose;
    }

    /**
     * The for-part element is used in a concert score to indicate the transposition for a transposed part created from that score. It is only used in score files that contain a concert-score element in the defaults. This allows concert scores with transposed parts to be represented in a single uncompressed MusicXML file.
     * 
     * Gets the value of the forPart property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the forPart property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getForPart().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ForPart }
     * </p>
     * 
     * 
     * @return
     *     The value of the forPart property.
     */
    public List<ForPart> getForPart() {
        if (forPart == null) {
            forPart = new ArrayList<>();
        }
        return this.forPart;
    }

    /**
     * Directives are like directions, but can be grouped together with attributes for convenience. This is typically used for tempo markings at the beginning of a piece of music. This element was deprecated in Version 2.0 in favor of the direction element's directive attribute. Language names come from ISO 639, with optional country subcodes from ISO 3166.
     * 
     * Gets the value of the directive property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the directive property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getDirective().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Attributes.Directive }
     * </p>
     * 
     * 
     * @return
     *     The value of the directive property.
     */
    public List<Attributes.Directive> getDirective() {
        if (directive == null) {
            directive = new ArrayList<>();
        }
        return this.directive;
    }

    /**
     * A measure-style indicates a special way to print partial to multiple measures within a part. This includes multiple rests over several measures, repeats of beats, single, or multiple measures, and use of slash notation.
     * 
     * Gets the value of the measureStyle property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the measureStyle property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getMeasureStyle().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link MeasureStyle }
     * </p>
     * 
     * 
     * @return
     *     The value of the measureStyle property.
     */
    public List<MeasureStyle> getMeasureStyle() {
        if (measureStyle == null) {
            measureStyle = new ArrayList<>();
        }
        return this.measureStyle;
    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <simpleContent>
     *     <extension base="<http://www.w3.org/2001/XMLSchema>string">
     *       <attGroup ref="{}print-style"/>
     *       <attribute ref="{http://www.w3.org/XML/1998/namespace}lang"/>
     *     </extension>
     *   </simpleContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "value"
    })
    public static class Directive {

        @XmlValue
        protected java.lang.String value;
        /**
         * Attempting to install the relevant ISO 2- and 3-letter
         *          codes as the enumerated possible values is probably never
         *          going to be a realistic possibility.  See
         *          RFC 3066 at http://www.ietf.org/rfc/rfc3066.txt and the IANA registry
         *          at http://www.iana.org/assignments/lang-tag-apps.htm for
         *          further information.
         * 
         *          The union allows for the 'un-declaration' of xml:lang with
         *          the empty string.
         * 
         */
        @XmlAttribute(name = "lang", namespace = "http://www.w3.org/XML/1998/namespace")
        protected java.lang.String lang;
        @XmlAttribute(name = "font-family")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        protected java.lang.String fontFamily;
        @XmlAttribute(name = "font-style")
        protected FontStyle fontStyle;
        @XmlAttribute(name = "font-size")
        protected java.lang.String fontSize;
        @XmlAttribute(name = "font-weight")
        protected FontWeight fontWeight;
        @XmlAttribute(name = "default-x")
        protected BigDecimal defaultX;
        @XmlAttribute(name = "default-y")
        protected BigDecimal defaultY;
        @XmlAttribute(name = "relative-x")
        protected BigDecimal relativeX;
        @XmlAttribute(name = "relative-y")
        protected BigDecimal relativeY;
        @XmlAttribute(name = "color")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        protected java.lang.String color;

        /**
         * Gets the value of the value property.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getValue() {
            return value;
        }

        /**
         * Sets the value of the value property.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setValue(java.lang.String value) {
            this.value = value;
        }

        /**
         * Attempting to install the relevant ISO 2- and 3-letter
         *          codes as the enumerated possible values is probably never
         *          going to be a realistic possibility.  See
         *          RFC 3066 at http://www.ietf.org/rfc/rfc3066.txt and the IANA registry
         *          at http://www.iana.org/assignments/lang-tag-apps.htm for
         *          further information.
         * 
         *          The union allows for the 'un-declaration' of xml:lang with
         *          the empty string.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getLang() {
            return lang;
        }

        /**
         * Sets the value of the lang property.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         * @see #getLang()
         */
        public void setLang(java.lang.String value) {
            this.lang = value;
        }

        /**
         * Gets the value of the fontFamily property.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getFontFamily() {
            return fontFamily;
        }

        /**
         * Sets the value of the fontFamily property.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setFontFamily(java.lang.String value) {
            this.fontFamily = value;
        }

        /**
         * Gets the value of the fontStyle property.
         * 
         * @return
         *     possible object is
         *     {@link FontStyle }
         *     
         */
        public FontStyle getFontStyle() {
            return fontStyle;
        }

        /**
         * Sets the value of the fontStyle property.
         * 
         * @param value
         *     allowed object is
         *     {@link FontStyle }
         *     
         */
        public void setFontStyle(FontStyle value) {
            this.fontStyle = value;
        }

        /**
         * Gets the value of the fontSize property.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getFontSize() {
            return fontSize;
        }

        /**
         * Sets the value of the fontSize property.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setFontSize(java.lang.String value) {
            this.fontSize = value;
        }

        /**
         * Gets the value of the fontWeight property.
         * 
         * @return
         *     possible object is
         *     {@link FontWeight }
         *     
         */
        public FontWeight getFontWeight() {
            return fontWeight;
        }

        /**
         * Sets the value of the fontWeight property.
         * 
         * @param value
         *     allowed object is
         *     {@link FontWeight }
         *     
         */
        public void setFontWeight(FontWeight value) {
            this.fontWeight = value;
        }

        /**
         * Gets the value of the defaultX property.
         * 
         * @return
         *     possible object is
         *     {@link BigDecimal }
         *     
         */
        public BigDecimal getDefaultX() {
            return defaultX;
        }

        /**
         * Sets the value of the defaultX property.
         * 
         * @param value
         *     allowed object is
         *     {@link BigDecimal }
         *     
         */
        public void setDefaultX(BigDecimal value) {
            this.defaultX = value;
        }

        /**
         * Gets the value of the defaultY property.
         * 
         * @return
         *     possible object is
         *     {@link BigDecimal }
         *     
         */
        public BigDecimal getDefaultY() {
            return defaultY;
        }

        /**
         * Sets the value of the defaultY property.
         * 
         * @param value
         *     allowed object is
         *     {@link BigDecimal }
         *     
         */
        public void setDefaultY(BigDecimal value) {
            this.defaultY = value;
        }

        /**
         * Gets the value of the relativeX property.
         * 
         * @return
         *     possible object is
         *     {@link BigDecimal }
         *     
         */
        public BigDecimal getRelativeX() {
            return relativeX;
        }

        /**
         * Sets the value of the relativeX property.
         * 
         * @param value
         *     allowed object is
         *     {@link BigDecimal }
         *     
         */
        public void setRelativeX(BigDecimal value) {
            this.relativeX = value;
        }

        /**
         * Gets the value of the relativeY property.
         * 
         * @return
         *     possible object is
         *     {@link BigDecimal }
         *     
         */
        public BigDecimal getRelativeY() {
            return relativeY;
        }

        /**
         * Sets the value of the relativeY property.
         * 
         * @param value
         *     allowed object is
         *     {@link BigDecimal }
         *     
         */
        public void setRelativeY(BigDecimal value) {
            this.relativeY = value;
        }

        /**
         * Gets the value of the color property.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getColor() {
            return color;
        }

        /**
         * Sets the value of the color property.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setColor(java.lang.String value) {
            this.color = value;
        }

    }

}
